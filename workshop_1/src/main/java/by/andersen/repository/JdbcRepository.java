package by.andersen.repository;

import by.andersen.annotations.AutoGenerated;
import by.andersen.exception.ResultSetMapException;
import by.andersen.utils.ReflectionUtils;
import by.andersen.utils.SqlScriptGenerator;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.sql.DataSource;
import jdk.jshell.spi.ExecutionControl.NotImplementedException;

public class JdbcRepository<T extends Serializable, ID> implements Repository<T, ID>, Serializable{

  private final DataSource dataSource;
  private final Class<T> entityClass;
  private final String saveSqlTemplate;
  private final String findByIdSqlTemplate;
  private final String findAllSqlTemplate;
  private final String deleteSqlTemplate;

  public JdbcRepository(DataSource dataSource, String currentSchema, String tableName, Class<T> entityClass) {
    this.dataSource = dataSource;
    this.entityClass = entityClass;
    this.saveSqlTemplate = SqlScriptGenerator.generateSave(currentSchema, tableName, entityClass);
    this.findByIdSqlTemplate = SqlScriptGenerator.generateFindById(currentSchema, tableName);
    this.findAllSqlTemplate = SqlScriptGenerator.generateFindAll(currentSchema, tableName);
    this.deleteSqlTemplate = SqlScriptGenerator.generateDelete(currentSchema, tableName);
  }

  @Override
  public void save(T entity) {
    try (Connection connection = dataSource.getConnection();
        PreparedStatement statement = connection.prepareStatement(saveSqlTemplate)) {
      Field[] nonStaticFields = ReflectionUtils.getNonStaticFields(entityClass);

      for (int i = 0; i < nonStaticFields.length; i++) {
        Field field = nonStaticFields[i];
        Object fieldValue = ReflectionUtils.getFieldValue(field, entity);
        System.out.println(fieldValue);
        if (field.getAnnotation(AutoGenerated.class) != null) {
          continue;
        } else if (field.getType().isEnum()) {
          fieldValue = fieldValue.toString();
        }

        statement.setObject(i, fieldValue);
      }

      statement.executeUpdate();
    } catch (SQLException e) {
      throw new RuntimeException("save sql statement failed", e);
    }
  }

  @Override
  public Optional<T> findById(ID id) {
    try (Connection connection = dataSource.getConnection();
        PreparedStatement statement = connection.prepareStatement(findByIdSqlTemplate)) {
      statement.setObject(1, id);
      ResultSet resultSet = statement.executeQuery();
      if (resultSet.next()) {
        T entity = mapRowToEntity(resultSet);
        return Optional.of(entity);
      }
    } catch (SQLException e) {
      throw new RuntimeException("findById sql statement failed", e);
    }

    return Optional.empty();
  }

  @Override
  public List<T> findAll() {
    List<T> entities = new ArrayList<>();
    try (Connection connection = dataSource.getConnection();
        PreparedStatement statement = connection.prepareStatement(findAllSqlTemplate);
        ResultSet resultSet = statement.executeQuery()) {
      while (resultSet.next()) {
        T entity = mapRowToEntity(resultSet);
        entities.add(entity);
      }
    } catch (SQLException e) {
      throw new RuntimeException("findAll sql statement failed", e);
    }

    return entities;
  }

  @Override
  public void delete(ID id) {
    try (Connection connection = dataSource.getConnection();
        PreparedStatement statement = connection.prepareStatement(deleteSqlTemplate)) {
      statement.setObject(1, id);
      statement.executeUpdate();
    } catch (SQLException e) {
      throw new RuntimeException("delete sql statement failed", e);
    }
  }

  private T mapRowToEntity(ResultSet resultSet) throws SQLException {
    T entity;
    try {
      Field[] nonStaticFields = ReflectionUtils.getNonStaticFields(entityClass);

      List<Class> types = Arrays.stream(nonStaticFields).map(Field::getType)
          .collect(Collectors.toCollection(ArrayList::new));

      List<Object> resultSetValues = new ArrayList<>();

      for (Field field: nonStaticFields) {
        resultSetValues.add(
            getResultSetValueForField(resultSet, field.getType(), field.getName())
        );
      }

      entity = entityClass
          .getDeclaredConstructor(types.toArray(Class[]::new))
          .newInstance(resultSetValues.toArray(Object[]::new));
    } catch (InstantiationException | IllegalAccessException | NoSuchMethodException |
             InvocationTargetException | NotImplementedException e) {
      throw new ResultSetMapException("Cannot map result set to entity " + entityClass, e);
    }

    return entity;
  }

  private Object getResultSetValueForField(ResultSet resultSet, Class fieldType, String fieldName)
      throws SQLException, NotImplementedException {
    if (fieldType == Integer.class || fieldType == int.class) {
      return resultSet.getInt(fieldName);
    } else if (fieldType == Long.class || fieldType == long.class) {
      return resultSet.getLong(fieldName);
    } else if (fieldType == String.class) {
      return resultSet.getString(fieldName);
    } else if (fieldType == Double.class || fieldType == double.class) {
      return resultSet.getDouble(fieldName);
    } else if (fieldType == Float.class || fieldType == float.class) {
      return resultSet.getFloat(fieldName);
    } else if (fieldType == BigDecimal.class) {
      return BigDecimal.valueOf(resultSet.getDouble(fieldName));
    } else if (fieldType == Boolean.class || fieldType == boolean.class) {
      return resultSet.getBoolean(fieldName);
    } else if (fieldType == java.util.Date.class) {
      return resultSet.getDate(fieldName);
    } else if (fieldType.isEnum()) {
      Class<? extends Enum> enumClass = (Class<? extends Enum>) fieldType;
      return Enum.valueOf(enumClass, resultSet.getString(fieldName));
    } else {
      throw new NotImplementedException("Map ResultSet to entity not implemented for " + fieldType);
    }
  }
}
